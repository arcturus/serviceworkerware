{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","lib/router.js","lib/simpleofflinecache.js","lib/staticcacher.js","lib/sww.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sww.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var sww = require('./lib/sww.js');\n\nself.ServiceWorkerWare = sww.ServiceWorkerWare;\nself.StaticCacher = sww.StaticCacher;\nself.SimpleOfflineCache = sww.SimpleOfflineCache;\n","'use strict';\n\n// Inspired by expressjs and shed (https://github.com/wibblymat/shed)\nfunction Router(options) {\n  this.options = options;\n  this.stack = [];\n}\n\nRouter.prototype.ALL_METHODS = 'all';\nRouter.prototype.methods = ['get', 'post', 'put', 'delete', 'head',\n  Router.prototype.ALL_METHODS];\n\n/**\n * Add a new route to the stack.\n * @param method (String) http verb to handle the request\n * @param path (Regexp) string or regexp to match urls\n * @param handler (Function) payload to be executed if url matches.\n */\nRouter.prototype.add = function r_add(method, path, handler) {\n  var pathRegexAndTags, pathRegex, namedPlaceholders;\n\n  method = this._sanitizeMethod(method);\n\n  // Parse simle string path into regular expression for path matching\n  pathRegexAndTags = this._parseSimplePath(path);\n  pathRegex = pathRegexAndTags.regexp;\n  namedPlaceholders = pathRegexAndTags.tags;\n\n  this.stack.push({\n    method: method,\n    path: pathRegex,\n    namedPlaceholders: namedPlaceholders,\n    handler: handler\n  });\n};\n\n/**\n * Create the utility methods .get .post ... etc.\n */\nRouter.prototype.methods.forEach(function(method) {\n  Router.prototype[method] = function(path, handler) {\n    return this.add(method, path, handler);\n  };\n});\n\nRouter.prototype.proxyMethods = function r_proxyPrototype(obj) {\n  var self = this;\n  this.methods.forEach(function(method) {\n    obj[method] = function(path, mw) {\n      if (typeof mw.onFetch !== 'function' && typeof mw !== 'function') {\n        throw new Error('This middleware cannot handle fetch request');\n      }\n      var handler = typeof mw.onFetch !== 'undefined' ?\n        mw.onFetch.bind(mw) : mw;\n      self.add(method, path, handler);\n    };\n  });\n};\n\n/**\n * Matches the given url and methods with the routes stored in\n * the stack.\n */\nRouter.prototype.match = function r_match(method, url) {\n  method = this._sanitizeMethod(method);\n  var matches = [];\n\n  var _this = this;\n  this.stack.forEach(function eachRoute(route) {\n    if (!(method === route.method || route.method === _this.ALL_METHODS)) {\n      return;\n    }\n\n    var groups = _this._routeMatch(url, route);\n    if (groups) {\n      route.handler.__params = groups;\n      matches.push(route.handler);\n    }\n  });\n\n  return matches;\n};\n\n/**\n * Performs a matching test for url against a route.\n * @param {String} the url to test\n * @param {route} the route to match against\n * @return {Object} an object with the portions of the url matching the named\n * placeholders or null if there is no match.\n */\nRouter.prototype._routeMatch = function (url, route) {\n  var groups = url.match(route.path);\n  if (!groups) { return null; }\n  return this._mapParameters(groups, route.namedPlaceholders);\n};\n\n/**\n * Assign names from named placeholders in a route to the matching groups\n * for an URL against that route.\n * @param {Array} groups from a successful match\n * @param {Array} names for those groups\n * @return a map of names of named placeholders and values for those matches.\n */\nRouter.prototype._mapParameters = function (groups, placeholderNames) {\n  return placeholderNames.reduce(function (params, name, index) {\n    params[name] = groups[index + 1];\n    return params;\n  }, Object.create(null));\n};\n\nRouter.prototype._sanitizeMethod = function(method) {\n  var sanitizedMethod = method.toLowerCase().trim();\n  if (this.methods.indexOf(sanitizedMethod) === -1) {\n    throw new Error('Method \"' + method + '\" is not supported');\n  }\n  return sanitizedMethod;\n};\n\n/**\n * Simple path-to-regex translation based on the Express \"string-based path\"\n * syntax.\n */\nRouter.prototype._parseSimplePath = function(path) {\n  // Check for named placeholder crowding\n  if (/\\:[a-zA-Z0-9]+\\:[a-zA-Z0-9]+/g.test(path)) {\n    throw new Error('Invalid usage of named placeholders');\n  }\n\n  // Check for mixed placeholder crowdings\n  var mixedPlaceHolders =\n    /(\\*\\:[a-zA-Z0-9]+)|(\\:[a-zA-Z0-9]+\\:[a-zA-Z0-9]+)|(\\:[a-zA-Z0-9]+\\*)/g;\n  if (mixedPlaceHolders.test(path.replace(/\\\\\\*/g,''))) {\n    throw new Error('Invalid usage of named placeholders');\n  }\n\n  // Try parsing the string and converting special characters into regex\n  try {\n    // Parsing anonymous placeholders with simple backslash-escapes\n    path = path.replace(/(.|^)[*]+/g, function(m,escape) {\n      return escape==='\\\\' ? '\\\\*' : (escape+'(?:.*?)');\n    });\n\n    // Parsing named placeholders with backslash-escapes\n    var tags = [];\n    path = path.replace(/(.|^)\\:([a-zA-Z0-9]+)/g, function (m, escape, tag) {\n      if (escape === '\\\\') { return ':' + tag; }\n      tags.push(tag);\n      return escape + '(.+?)';\n    });\n\n    return { regexp: RegExp(path + '$'), tags: tags };\n  }\n\n  // Failed to parse final path as a RegExp\n  catch (ex) {\n    throw new Error('Invalid path specified');\n  }\n};\n\n\nmodule.exports = Router;\n","/* global Promise, caches */\n'use strict';\n\nvar debug = 0 ? console.log.bind(console, '[SimpleOfflineCache]') :\n function(){};\n\n// Default Match options, not exposed.\nvar DEFAULT_MATCH_OPTIONS = {\n  ignoreSearch: false,\n  ignoreMethod: false,\n  ignoreVary: false\n};\nvar DEFAULT_MISS_POLICY = 'fetch';\n// List of different policies\nvar MISS_POLICIES = [\n  DEFAULT_MISS_POLICY\n];\n\nvar DEFAULT_CACHE_NAME = 'offline';\n\n\n/**\n * Constructor for the middleware that serves the content of a\n * cache specified by it's name.\n * @param {string} cacheName Name of the cache that will be serving the content\n * @param {object} [options] Object use to setup the cache matching alternatives\n * @param {string} [missPolicy] Name of the policy to follow if a request miss\n *                 when hitting the cache.\n */\nfunction SimpleOfflineCache(cacheName, options, missPolicy) {\n  this.cacheName = cacheName || DEFAULT_CACHE_NAME;\n  this.options = options || DEFAULT_MATCH_OPTIONS;\n  this.missPolicy = missPolicy || DEFAULT_MISS_POLICY;\n  if (MISS_POLICIES.indexOf(this.missPolicy) === -1) {\n    console.warn('Policy ' + missPolicy + ' not supported');\n    this.missPolicy = DEFAULT_MISS_POLICY;\n  }\n}\n\nSimpleOfflineCache.prototype.onFetch = function soc_onFetch(request, response) {\n  // If another middleware layer already have a response, the simple cache\n  // just pass through the response and does nothing.\n  if (response) {\n    return Promise.resolve(response);\n  }\n\n  var clone = request.clone();\n  var _this = this;\n  debug('Handing fetch event: ' + clone.url);\n  return this.ensureCache().then(function(cache) {\n    return cache.match(clone, _this.options).then(function(res) {\n      if (res) {\n        return res;\n      }\n\n      // So far we just support one policy\n      switch(_this.missPolicy) {\n        case DEFAULT_MISS_POLICY:\n          return fetch(request);\n      }\n    });\n  });\n};\n\nSimpleOfflineCache.prototype.ensureCache = function soc_ensureCache() {\n  if (!this.cacheRequest) {\n    this.cacheRequest = caches.open(this.cacheName);\n  }\n  return this.cacheRequest;\n};\n\nmodule.exports = SimpleOfflineCache;\n","/* globals caches, Promise, Request */\n'use strict';\n\nfunction StaticCacher(fileList) {\n  if (!Array.isArray(fileList) || fileList.length === 0) {\n    throw new Error('Invalid file list');\n  }\n  this.files = fileList;\n}\n\nStaticCacher.prototype.onInstall = function sc_onInstall() {\n  var self = this;\n  return this.getDefaultCache().then(function(cache) {\n    return self.addAll(cache, self.files);\n  });\n};\n\nStaticCacher.prototype.getDefaultCache = function sc_getDefaultCache() {\n  if (!this.cacheRequest) {\n    this.cacheRequest = caches.open('offline');\n  }\n  return this.cacheRequest;\n};\n\nStaticCacher.prototype.addAll = function(cache, urls) {\n  if (!cache) {\n    throw new Error('Need a cache to store things');\n  }\n  // Polyfill until chrome implements it\n  if (typeof cache.addAll !== 'undefined') {\n    return cache.addAll(urls);\n  }\n\n  var promises = [];\n  var self = this;\n  urls.forEach(function(url) {\n    promises.push(self.fetchAndCache(new Request(url), cache));\n  });\n\n  return Promise.all(promises);\n};\n\nStaticCacher.prototype.fetchAndCache =\nfunction sc_fetchAndCache(request, cache) {\n\n  return fetch(request.clone()).then(function(response) {\n    if (parseInt(response.status) < 400) {\n      cache.put(request.clone(), response.clone());\n    }\n    return response;\n  });\n};\n\n\nmodule.exports = StaticCacher;\n","/* global fetch, BroadcastChannel, clients, Promise, Request, Response */\n'use strict';\n\nvar debug = 1 ? console.log.bind(console, '[ServiceWorkerWare]') : function(){};\nvar StaticCacher = require('./staticcacher.js');\nvar SimpleOfflineCache = require('./simpleofflinecache.js');\nvar Router = require('./router.js');\n\nvar ERROR = 'error';\nvar CONTINUE = 'continue';\nvar TERMINATE = 'terminate';\nvar TERMINATION_TOKEN = {};\n\nfunction DEFAULT_FALLBACK_MW(request) {\n  return fetch(request);\n}\n\nfunction ServiceWorkerWare(options) {\n  options = options || {};\n  if (typeof options === 'function' || options.onFetch) {\n    options = { fallbackMiddleware: options };\n  }\n  options.autoClaim = ('autoClaim' in options) ? options.autoClaim : true;\n  this.middleware = [];\n  this.router = new Router({});\n  this.router.proxyMethods(this);\n\n  this.fallbackMw = options.fallbackMiddleware || DEFAULT_FALLBACK_MW;\n  this.autoClaim = options.autoClaim;\n}\n\nServiceWorkerWare.prototype.init = function sww_init() {\n  // lifecycle events\n  addEventListener('install', this);\n  addEventListener('activate', this);\n  addEventListener('beforeevicted', this);\n  addEventListener('evicted', this);\n\n  // network events\n  addEventListener('fetch', this);\n\n  // misc events\n  addEventListener('message', this);\n  // XXX: Add default configuration\n};\n\n/**\n * Handle and forward all events related to SW\n */\nServiceWorkerWare.prototype.handleEvent = function sww_handleEvent(evt) {\n  debug('Event received: ' + evt.type);\n  switch(evt.type) {\n    case 'install':\n      this.onInstall(evt);\n      break;\n    case 'fetch':\n      this.onFetch(evt);\n      break;\n    case 'activate':\n      this.onActivate(evt);\n      break;\n    case 'message':\n    case 'beforeevicted':\n    case 'evicted':\n      this.forwardEvent(evt);\n      break;\n    default:\n      debug('Unhandled event ' + evt.type);\n  }\n};\n\nServiceWorkerWare.prototype.onFetch = function sww_onFetch(evt) {\n  var steps = this.router.match(evt.request.method, evt.request.url);\n\n  // Push the fallback middleware at the end of the list.\n  // XXX bug 1165860: Decorating fallback MW with `stopIfResponse` until\n  // 1165860 lands\n  steps.push((function(req, res) {\n    if (res) {\n      return Promise.resolve(res);\n    }\n    return this.fallbackMw(req, res);\n  }).bind(this));\n\n  evt.respondWith(this.executeMiddleware(steps, evt.request));\n};\n\n/**\n * Run the middleware pipeline and inform if errors preventing respondWith()\n * to swallow the error.\n *\n * @param {Array} the middleware pipeline\n * @param {Request} the request for the middleware\n */\nServiceWorkerWare.prototype.executeMiddleware = function (middleware, request) {\n  var response = this.runMiddleware(middleware, 0, request, null);\n  response.catch(function (error) { console.error(error); });\n  return response;\n};\n\n/**\n * Pass through the middleware pipeline, executing each middleware in a\n * sequence according to the result from each execution.\n *\n * Each middleware will be passed with the request and response from the\n * previous one in the pipeline. The response from the latest one will be\n * used to answer from the service worker. The middleware will receive,\n * as the last parameter, a function to stop the pipeline and answer\n * immediately.\n *\n * A middleware run can lead to continuing execution, interruption of the\n * pipeline or error. The next action to be performed is calculated according\n * the conditions of the middleware execution and its return value.\n * See normalizeMwAnswer() for details.\n *\n * @param {Array} middleware pipeline.\n * @param {Number} middleware to execute in the pipeline.\n * @param {Request} the request for the middleware.\n * @param {Response} the response for the middleware.\n */\nServiceWorkerWare.prototype.runMiddleware =\nfunction (middleware, current, request, response) {\n  if (current >= middleware.length) {\n    return Promise.resolve(response);\n  }\n\n  var mw = middleware[current];\n  if (request) { request.parameters = mw.__params; }\n  var endWith = ServiceWorkerWare.endWith;\n  var answer = mw(request, response, endWith);\n  var normalized =\n    ServiceWorkerWare.normalizeMwAnswer(answer, request, response);\n\n  return normalized.then(function (info) {\n    switch (info.nextAction) {\n      case TERMINATE:\n        return Promise.resolve(info.response);\n\n      case ERROR:\n        return Promise.reject(info.error);\n\n      case CONTINUE:\n        var next = current + 1;\n        var request = info.request;\n        var response = info.response;\n        return this.runMiddleware(middleware, next, request, response);\n    }\n  }.bind(this));\n};\n\n/**\n * A function to force interruption of the pipeline.\n *\n * @param {Response} the response object that will be used to answer from the\n * service worker.\n */\nServiceWorkerWare.endWith = function (response) {\n  if (arguments.length === 0) {\n    throw new Error('Type error: endWith() must be called with a value.');\n  }\n  return [TERMINATION_TOKEN, response];\n};\n\n/**\n * A middleware is supposed to return a promise resolving in a pair of request\n * and response for the next one or to indicate that it wants to answer\n * immediately.\n *\n * To allow flexibility, the middleware is allowed to return other values\n * rather than the promise. For instance, it is allowed to return only a\n * request meaning the next middleware will be passed that request but the\n * previous response untouched.\n *\n * The function takes into account all the scenarios to compute the request\n * and response for the next middleware or the intention to terminate\n * immediately.\n *\n * @param {Any} non normalized answer from the middleware.\n * @param {Request} request passed as parameter to the middleware.\n * @param {Response} response passed as parameter to the middleware.\n */\nServiceWorkerWare.normalizeMwAnswer = function (answer, request, response) {\n  if (!answer || !answer.then) {\n    answer = Promise.resolve(answer);\n  }\n  return answer.then(function (value) {\n    var nextAction = CONTINUE;\n    var error, nextRequest, nextResponse;\n    var isArray = Array.isArray(value);\n\n    if (isArray && value[0] === TERMINATION_TOKEN) {\n      nextAction = TERMINATE;\n      nextRequest = request;\n      nextResponse = value[1] || response;\n    }\n    else if (value === null) {\n      nextRequest = request;\n      nextResponse = null;\n    }\n    else if (isArray && value.length === 2) {\n      nextRequest = value[0];\n      nextResponse = value[1];\n    }\n    else if (value instanceof Response) {\n      nextRequest = request;\n      nextResponse = value;\n    }\n    else if (value instanceof Request) {\n      nextRequest = value;\n      nextResponse = response;\n    }\n    else {\n      var msg = 'Type error: middleware must return a Response, ' +\n                'a Request, a pair [Response, Request] or a Promise ' +\n                'resolving to one of these types.';\n      nextAction = ERROR;\n      error = new Error(msg);\n    }\n\n    return {\n      nextAction: nextAction,\n      request: nextRequest,\n      response: nextResponse,\n      error: error\n    };\n  });\n};\n\n/**\n * Walk all the middleware installed asking if they have prerequisites\n * (on the way of a promise to be resolved) when installing the SW.\n */\nServiceWorkerWare.prototype.onInstall = function sww_oninstall(evt) {\n  var installation = this.getFromMiddleware('onInstall');\n  evt.waitUntil(installation);\n};\n\n/**\n * Walk all the installed middleware asking if they have prerequisites\n * (on the way of a promise to be resolved) when SW activates.\n */\nServiceWorkerWare.prototype.onActivate = function sww_activate(evt) {\n  var activation = this.getFromMiddleware('onActivate');\n  if (this.autoClaim) {\n    activation =\n      activation.then(function claim() { return self.clients.claim(); });\n  }\n  evt.waitUntil(activation);\n};\n\n/**\n * Returns a promise gathering the results for executing the same method for\n * all the middleware.\n * @param {Function} the method to be executed.\n * @param {Promise} a promise resolving once all the results have been gathered.\n */\nServiceWorkerWare.prototype.getFromMiddleware =\nfunction sww_getFromMiddleware(method) {\n  var tasks = this.middleware.reduce(function (tasks, mw) {\n    if (typeof mw[method] === 'function') {\n      tasks.push(mw[method]());\n    }\n    return tasks;\n  }, []);\n  return Promise.all(tasks);\n};\n\n/**\n * Register a new middleware layer, they will treat the request in\n * the order that this layers have been defined.\n * A middleware layer can behave in the ServiceWorker in two ways:\n *  - Listening to SW lifecycle events (install, activate, message).\n *  - Handle a request.\n * To handle each case (or both) the middleware object should provide\n * the following methods:\n * - on<SW LiveCiclyeEvent>: for listening to SW lifeciclye events\n * - onFetch: for handling fetch urls\n */\nServiceWorkerWare.prototype.use = function sww_use() {\n  // If the first parameter is not a function we will understand that\n  // is the path to handle, and the handler will be the second parameter\n  if (arguments.length === 0) {\n    throw new Error('No arguments given');\n  }\n  var mw = arguments[0];\n  var path = '*';\n  var method = this.router.ALL_METHODS;\n  if (typeof mw === 'string') {\n    path = arguments[0];\n    mw = arguments[1];\n    var kind = typeof mw;\n    if (!mw || !(kind === 'object' || kind === 'function')) {\n      throw new Error('No middleware specified');\n    }\n    if (Router.prototype.methods.indexOf(arguments[2]) !== -1) {\n      method = arguments[2];\n    }\n  }\n\n  this.middleware.push(mw);\n  // Add to the router just if middleware object is able to handle onFetch\n  // or if we have a simple function\n  var handler = null;\n  if (typeof mw.onFetch === 'function') {\n    handler = mw.onFetch.bind(mw);\n  } else if (typeof mw === 'function') {\n    handler = mw;\n  }\n  if (handler) {\n    this.router.add(method, path, handler);\n  }\n  // XXX: Attaching the broadcastMessage to mw that implements onMessage.\n  // We should provide a way to get a reference to the SWW object and do\n  // the broadcast from there\n  if (typeof mw.onMessage === 'function') {\n    mw.broadcastMessage = this.broadcastMessage;\n  }\n};\n\n\n/**\n * Forward the event received to any middleware layer that has a 'on<Event>'\n * handler\n */\nServiceWorkerWare.prototype.forwardEvent = function sww_forwardEvent(evt) {\n  this.middleware.forEach(function(mw) {\n    var handlerName = 'on' + evt.type.replace(/^[a-z]/,\n      function(m){\n         return m.toUpperCase();\n      }\n    );\n    if (typeof mw[handlerName] !== 'undefined') {\n      mw[handlerName].call(mw, evt);\n    }\n  });\n};\n\n/**\n * Broadcast a message to all worker clients\n * @param msg Object the message\n * @param channel String (Used just in Firefox Nightly) using broadcastchannel\n * api to deliver the message, this parameter can be undefined as we listen for\n * a channel undefined in the client.\n */\nServiceWorkerWare.prototype.broadcastMessage = function sww_broadcastMessage(\n  msg, channel) {\n  // XXX: Until https://bugzilla.mozilla.org/show_bug.cgi?id=1130685 is fixed\n  // we can use BroadcastChannel API in Firefox Nightly\n  if (typeof BroadcastChannel === 'function') {\n    var bc = new BroadcastChannel(channel);\n    bc.postMessage(msg);\n    bc.close();\n    return Promise.resolve();\n  } else {\n    // This is suppose to be the way of broadcasting a message, unfortunately\n    // it's not working yet in Chrome Canary\n    return clients.matchAll().then(function(consumers) {\n      consumers.forEach(function(client) {\n        client.postMessage(msg);\n      });\n    });\n  }\n};\n\nServiceWorkerWare.decorators = {\n\n  ifNoResponse: function (mw) {\n    return function (req, res, endWith) {\n      if (res) { return [req, res]; }\n      return mw(req, res, endWith);\n    };\n  },\n\n  stopAfter: function (mw) {\n    return function (req, res, endWith) {\n      var answer = mw(req, res, endWith);\n      var normalized = ServiceWorkerWare.normalizeMwAnswer(answer, req, res);\n\n      return normalized.then(function (info) {\n        if (info.nextAction === 'error') {\n          return Promise.reject(info.error);\n        }\n        return endWith(info.response);\n      });\n    };\n  }\n};\n\nmodule.exports = {\n  ServiceWorkerWare: ServiceWorkerWare,\n  StaticCacher: StaticCacher,\n  SimpleOfflineCache: SimpleOfflineCache\n};\n"]}